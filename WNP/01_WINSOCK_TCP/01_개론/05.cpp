/******************************************************************

  Chapter 1. 윈속에 대한 소개 

	1) TCP/IP 통신(연결 지향 통신) 
		 서버 : 소켓 생성 -> listen -> bind -> accept  
******************************************************************/



//---------------------------------------------------------------- 
//   1) TCP 서버/클라이언트 구조(연결 지향 통신)
//---------------------------------------------------------------- 
/*
   간단한 서버/클라이언트 구현

   서버 클라이언트 동작 방식
   1) 서버는 먼저 실행하여 클라이언트가 접속하기를 
      기다린다.(listen)
   2) 클라이언트가 서버에 접속(connect)하여 데이터를 보낸다.(send)
   3) 서버는 클라이언트 접속을 수용하고(accept) 클라이언트가 보낸
       데이터를 받아서(recv) 처리한다.
   4) 서버는 처리한 데이터를 클라이언트에 보낸다.(send)
   5) 클라이언트는 서버가 보낸 데이터를 받아서 (recv) 자신의 목적에 
      맞게 사용한다.

   => 웹 클라이언트 / 웹 서버 
      HTTP를 이용하여 통신
	  HTTP는 TCP에 기반한 프로토콜임
	  텔넷서버/클라이언트
	  FTP서버/클라이언트 등에도 위의 방식이 동일하게 적용된다.


   * 동작 원리  
   1) 서버는 소켓을 생성한 후 클라이언트가 접속하기를 기다린다.
      서버가 사용하는 소켓은 특정 포트 번호와 결합되어(bind) 있어서
	  이 포트 번호로 접속하느 클라이언트만 수용가능하다.

   2) 클라이언트가 접속한다. 이때 TCP 프로토콜 수준에서 연결 설정을
      위한 패킷 교환이 일어난다.

   3) TCP 프로토콜 수준의 연결 절차가 끝나면 , 서버는 접속한 클라이언트
      와 통신할 수 있는 새로운 소켓을 생성한다.
	  서버가 클라이언트와 데이터를 주고받을 때는 이 소켓을 사용한다.
	  기존의 소켓은 새로운 클라이언트 접속을 수용하는 용도로 계속
	  사용한다.

   4) 두 클라이언트가 접속한 후의 상태는 서버측에서는 총 3개의 소켓이
      존재하며, 이 중 두 소켓이 실제 클라이언트와 통신하는 용도로 
	  사용된다.
*/


//---------------------------------------------------------------- 
//   1) TCP/IP 통신(연결 지향 통신)
//---------------------------------------------------------------- 
/*
	신뢰성 있는 데이터 전송을 제공 
	응용 프로그램간 TCP를 통하여 통신하면 두 개의 지점간 가상연결
	(virtual connection)이 이루어짐
	양방향 스트림 방식의 통신이 가능해진다.

    
	(서버)
	   클라이언트의 요청에 응답하기 위해 연결을 기다린다.
		  접속 가능한 주소로 연결을 기다린다.(IP & PORT)

		[서버]
		socket()	==>	bind()	==>	listen()	=> accept()
	
		[클라이언트]
		socket()	==>	connect()

     [서버]
  	 1) socket()  소켓 생성
	 2) bind()    지역 IP주소와 지역 포트번호 결정
	 3) listen()  TCP 상태를 LISTENING 으로 변경
	 4) accept()  자신에 접속한 클라이언트와 통신할 수 있는 새로운
	              소켓을 생성, 이때 원격 IP주소와 원격 포트번호가 결정됨
	 5) send(), recv() 데이터 전송함수를 이용 통신 수행
	 6) closesocket() 소켓 종료
	 7) 새로운 클라이언트 접속이 들어올때마다 4-5과정 반복 

     [클라이언트]
  	 1) socket() 함수를 이용하여 소켓을 생성
	 2) connect() 함수를 이용하여 서버에 접속
	 3) send(), recv() 등의 데이터 전송함수를 이용하여 서버와 통신 수행
	 4) closesocket() 함수를 이용하여 소켓 종료 


*/



//---------------------------------------------------------------- 
//   2) TCP/IP 통신 : 서버(바인딩)
//---------------------------------------------------------------- 
/*
	서버는 클라이언트가 접속 가능한 주소로 소켓을 바인드(bind)해야 함

	int bind(
		SOCKET					s;
		const struct sockaddr	FAR *name;
		int						namelen;
	);

	1인자) 클라이언트의 연결을 기다릴 소켓
	2인자) 구조체 포인터
	        프로토콜에 해당하는 구조체에 값을 채운 후 sockaddr포인터로
			형변환(TCP/IP : SOCKADDR_IN 타입)
	3인자) 두번째 구조체의 크기 입력(byte단위) 


    ex)

	SOCKET		s;
	SOCKADR_IN	tcpaddr;
	int			port		= 5000;

	s	= socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    tcpaddr.sin_family		= AF_INET;
	tcpaddr.sin_port		= htons(port);
	tcpaddr.sin_addr.s_addr = htonl(INADDR_ANY);

	// 주소 할당
	bind( s, (SOCKADDR*)&tcpaddr,  sizeof(tcpaddr) );

    // 에러발생시 SOCK_ERROR 리턴
*/



//---------------------------------------------------------------- 
//   2) TCP/IP 통신 : 서버(연결 대기)
//---------------------------------------------------------------- 
/*
	서버 소켓을 연결 대기 상태(listening mode)로 놓는다.
	소켓과 결합된 TCP 포트 상태를 LISTENING 상태로 바꾸는 역할

	소켓이 연결을 기다리도록 한다.
	이는 클라이언트 접속을 받아들일 수 있는 상태를 의미 

    int listen(
		SOCKET		s,
		int			backlog
	);

	1인자)  바인드된 소켓
	2인자)	들어오는 연결을 대기시킬 수 있는 최대 개수 
	        여러개의 연결이 동시에 들어올 경우 유효한 숫자 
			ex) 2로 설정
			    같은 시간에 3개의 연결이 들어온 경우
				2개의 연결 요청은 대기 큐에 들어가서 정상적 처리
				1개는 WSAECONNREFUSED 에러 발생 실패 처리 

			    서버가 연결을 수락하면 대기큐에서 제거
				잘못된 수치는 내부적으로 적당한 값으로 교체됨 
				정확한 값을 찾는 함수는 제공되지 않음 

				backlog 값을 바꾸려면 언제라도 listen 함수를 다시 
				호출


*/



//---------------------------------------------------------------- 
//   2) TCP/IP 통신 : 서버(연결 수락)
//---------------------------------------------------------------- 
/*
	SOCKET	accept(
		SOCKET				s;
		struct sockaddr	FAR *addr;
		int				FAR *addrlen;
	);

	1인자) 연결 대기 모드에 있는 소켓
	2인자) SOCKADDR_IN의 주소
	3인자) SOCKADDR_IN의 주소의 길이 

    대기 큐에 있는 첫번째 연결 요청 처리 
	2인자)에 연결을 요청한 클라이언트의 주소 정보가 채워진다.
	3인자)에 연결된 소켓의 주소 구조체 길이가 리턴된다.

	연결을 요청한 클라이언트와 통신할 새로운 소켓을 만들어서 리턴한다.

	원래 소켓은 계속 연결 대기모드로 남아서 다른 연결을 기다린다.

    접속한 클라이언트가 없을 경우 accept() 함수는 서버를 대기상태
	  (wait state) 로 만든다. 
	  작업 관리자로 확인하면 CPU 사용율이 0임을 알수 있다.

    에러 발생) INVALID_SOCKET을 리턴 



*/



//---------------------------------------------------------------- 
//   2) TCP/IP 통신 :  Server example
//---------------------------------------------------------------- 

#include <winsock2.h>

#define PORT	6000
void main()
{
	WSADATA			wsaData;
	SOCKET			LSocket;
	SOCKET			CSocket;
	SOCKADDR_IN		SAddr;
	SOCKADDR_IN		CAddr;
	int				CAddr_len;

	// 1. 윈속 라이브러리 2.2 초기화
	WSAStartup(MAKEWORD(2,2), &wsaData);


	// 2. 연결을 기다리기 위한 소켓 생성
	LSocket	= socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);


	// 3. bind 하기 위한 주소 지정 및 bind
    SAddr.sin_family		= AF_INET;
	SAddr.sin_port		= htons(PORT);
	SAddr.sin_addr.s_addr = htonl(INADDR_ANY);

	bind( LSocket, (SOCKADDR*)&SAddr,  sizeof(SAddr) );


	// 4. 클라이언트의 연결을 기다림 일반적으로 5
	listen( LSocket, 5);


	// 5. 새로운 연결을 하나 수락
	CSocket	= accept(CSocket, (SOCKADDR*)&CAddr, &CAddr_len);


	// 6. 소켓 해제
	closesocket(CSocket);
	closesocket(LSocket);


	// 7. 윈속 사용 종료 

	WSACleanup();
}
