/******************************************************************

  Chapter 1. 윈속에 대한 소개 (UDP)

	1) 데이터 수신  
	2) example(수신)
	3) 데이터 송신
	4) example(전송)
******************************************************************/


//---------------------------------------------------------------- 
//   0) UDP & TCP
//---------------------------------------------------------------- 
/*
 UDP : TCP와 더불어 대표적인 전송 계층 프로토콜임 
 (UDP(Use Dategram Protocol)
	      
	1) 포트 번호를 이용하여 주소를 지정한다.
	   두 애플리케이션이 통신하기 위해 반드시 포트번호를 결정

    2) 데이터 오류를 체크한다.
	   IP가 제공하는 오류 체크 기능은 프로토콜 동작을 위해 반드시 필요한 
	   부분에만 국한한다.

       즉 IP 헤더에 대한 오류는 체크하지만 데이터에 대한 오류는 
	   체크하지 않는다.
	   반면 , TCP 와 UDP 는 헤더와 데이터에 대한 오류를 체크한다.



    TCP  & UTP 차이점 

		  TCP								UDP
	---------------------------------------------------------------
	(1)   연결형 프로토콜                   비연결형 프로토콜
	      - 연결이 성공해야 통신 가능       - 연결 없이 통신 가능
	
	(2)   데이터 경계를 구분하지 않음       데이터 경계를 구분함
	      - 바이트 스트림 서비스            - 데이터크램 서비스 

    (3)   신뢰성 있는 데이터 전송           비신뢰적인 데이터 전송
	      - 데이터를 재전송함               - 데이터를 재전송하지 않음 

    (4)   1:1 통신                          1  : 1  통신 (unicast), 
											1  : 다 통신 (broadcast)
											다 : 다 통신 (multicast)

    => 설명 
	(1) 연결을 하지 않으므로 connect 함수를 사용하지 않는다. 
	    몇 가지 이유로 인해 함수를 사용하는 경우도 있다. 

    (2) 데이터 경계 구분을 위한 작업을 애플리 케이션이 하지 않아도 된다. 

	(3) 프로토콜 수준에서 신뢰성 있는 데이터 전송을 보장하지 않는다. 
	    필효하다면 애플리케이션 수준에서 신뢰성 있는 데이터 전송 기능을 
		구현해야 한다. 

    (4) 간단한 소켓 함수 절차만 따르면 다자가 통신을 쉽게 구현할 수 있다.

    -----------------
    ==> UDP & TCP 는 모두 Checksum을 이용하여 데이터 오류를 체크한다. 
	    
		TCP :  도착한 데이터에 오류가 있다고 판단되도 이 데이터를 
		       애플리케이션에 보낸다. 
			   각 데이터의 순서 유지를 위해 각 바이트마다 번호를 
			   부여한다.

        UDP :  도착한 데이터에 오류가 있다고 판단되면 이 데이터를 
		       데이터 전송 계층
		       에서 그냥 버려버린다.(애플리케이션이 모름)
			   UDP는 데이터 전송 순서를 알지 못한다.
			   신뢰성 있는 데이터 전송을 하려면

			   데이터 재전송 + 데이터 순서 유지 , 이 두가지 기능을 
			   반드시 구현해야  한다.

               또한 속도가 서로 다른 컴퓨터에서 실행되는 애플리케이션이
			   UDP를 이용하여 대량의 데이터를 주고 받으려면 흐름 
			   제어기능까지 구현해야 한다. 

*) 동작 원리 

  UDP 서버는 TCP 서버와 달리 하나의 소켓으로 다수의 클라이언트에 대한
  서비스를 할 수 있다. 

  - 서버는 소켓을 생성한 후 클라이언트가 데이터를 보내기를 기다린다.
    특정 포트번호와 소켓이 결합되어 있어서 이 포트 번호로 보내는 데이터만 
	수신할 수 있다.(bind)

  - 클라이언트는 접속 과정 없이 곧바로 서버와 데이터를 주고 받는다.
    (sendto, recvfrom)

  - 또 다른 클라이언트 역시 접속 과정 없이 곧바로 서버와 데이터를 주고
    받는다.(sendto, recvfrom)

  - 즉, 하나의 서버 소켓과 다수의 클라이언트 간의 통신이 가능하다.
*/



//---------------------------------------------------------------- 
//   1) 데이터 수신
//---------------------------------------------------------------- 
/*
	비연결형 통신(connectionless communication) 은
	연결지향 통신(connection-oriented communication)과는 다르게 작동

	IP에서 비연결형 통신은 UDP/IP를 통하여 이루어진다.
	UDP는 데이터 전송의 신뢰성을 제공하지 않는다.
	다수의 목적지에 데이터를 전송할 수 있으며 
	다수의 전송측으로부터 수신이 가능하다.(연결이라는 개념이 없다.)

	데이터가 정확이 전송되었는지 확인이 불가능하다.
	(데이터그램에 실려 개별적인 메시지가 전달된다.)




	recvfrom  & WSARecv

	int recvfrom(
		SOCKET			s,
		char FAR		*buf,
		int				len,
		int				flags,
		struct sockeaddr FAR *from,
		int				 FAR *fromlen
	);

    1인자) 데이터를 수신할 소켓
	2인자) 수신된 데이터를 담을 char형 버퍼
	3인자) 수신하길 원하는 크기 or 버퍼의 크기
	4인자) 0
	5인자) 데이터를 보낸쪽의 주소가 채워진다.
	6인자) 구조체의 크기 


    수신 버퍼에 도착한 데이터를 애플리케이션 버퍼로 복사하는 
	역할을 한다
	 recv() 함수와의 차이점은 한 번에 하나의 UDP 데이터만 읽을 
	 수 있다는 점임.
	 즉 버퍼를 크게  잡는다고 많은 데이터를 한꺼번에 읽을 수 
	 있는 것은 아니다. 

 => 주의 사항
	 - sendto() 함수로 보낸 데이터는 독립적인 UDP 패킷으로 만들어져 
	   전송되며,
	   수신측에서는 한번의 recvfrom()함수 호출로 이 데이터를 읽는다.
	   메시지 경계 필요가 없다. 

     - UDP 소켓에 대해 recvfrom() 함수를 호출할 경우 리턴값이 0이 될 
	   수 있으며, 
	   이 경우 연결 종료를 의미하는 것은 아니다.
	   반면 TCP 소켓에 대해 recv()함수를 호출할 경우 리턴값이 0은 
	   정상 종료를 의미한다.

     - 블로킹 소켓의 경우, 도달한 데이터가 없으면 recvfrom() 함수 
	   호출시 블록 된다. 
*/



//---------------------------------------------------------------- 
//	4) example(수신)
//---------------------------------------------------------------- 
/*
#include <winsock2.h>

#define PORT	5000
void main()
{
	WSADATA			wsaData;
	SOCKET			RecSocket;
	SOCKADDR_IN		RecAddr;

	char			recvbuff[1024];
	int				nBytes		= 1024;

	SOCKADDR_IN		SenAddr;
	int				SenAddrsize	= sizeof(SenAddr);

	

	// 1. 윈속 라이브러리 2.2 초기화
	WSAStartup(MAKEWORD(2,2), &wsaData);


	// 2. 연결을 기다리기 위한 소켓 생성
	RecSocket	= socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);


	// 3. bind 하기 위한 주소 지정 및 bind
    RecAddr.sin_family		= AF_INET;
	RecAddr.sin_port			= htons(PORT);
	RecAddr.sin_addr.s_addr	= htonl(INADDR_ANY);

	bind(RecSocket, (SOCKADDR*)&SenAddr, SenAddrsize);


	// 4. 데이터 수신
	recvfrom(RecSocket, recvbuff, nBytes, 0, 
			(SOCKADDR*)&SenAddr, &SenAddrsize );

	
	// 5. 소켓 해제
	closesocket( RecSocket);

	// 6. 윈속 사용 종료 
	WSACleanup();
}
*/




//---------------------------------------------------------------- 
//   3) 데이터 송신
//---------------------------------------------------------------- 
/*

	int sendto(
		SOCKET						s,
		const char FAR				*buf,
		int							len,
		int							flags
		const struct sockaddr FAR   *to,
		int							tolen
	);


	1인자) 데이터를 전송하길 원하는 연결된 소켓
	2인자) 전송할 데이터가 담긴 char형 버퍼 
	3인자) len은 전송할 데이터의 크기 
	4인자) 0
	5인자) 데이터를 전송할  주소가 채워진다.
	6인자) 구조체의 크기 

  => 주의할 사항 
	 - TCP 소켓과 달리 UDP 소켓은 송신버퍼가 별도로 존재하지 않는다.
	   애플리케이션 데이터는 커널(운영체제) 영역에 복사되어 전송된 후 
	   곧바로 버려진다.
	   sendto() 함수가 리턴했다고 실제 데이터 전송이 완료된 것은 
	   아니다.
	   데이터 전송이 끝났더라도 상대방이 받았는지 확인할 수는 없다. 

     - sendto() 함수로 보낸 데이터는 독립적인 UDP 데이터그램(패킷)으로 
	   만들어져 전송되며, 
	   수신측에서는 한 번의 recvfrom() 함수 호출로 이 데이터를 읽을 수 
	   있다. 
	   즉 TCP와 달리 UDP에서는 애플리케이션 수준에서 메시지 경계를 
	   구분하기 위한 작업을 할 필요가 없다. 

     - UDP 소켓에 대해 sendto() 함수를 호출할 경우 한 번에 보낼 수 
	   있는 데이터의 크기에 제한이 있다. 
	   최대값은 65507( 65535- 20(IP해더 크기) - 8(UDP 해더 크기) 
	   바이트이다.
	   실제적으로 이 보다 훨씬 작은 크기를 사용하는 것이 바람직하다.
	   512 byte 보다 작은 데이터를 보내는 것 권장

     - 블로킹 소켓의 경우, 커널 영역에 복사할 공간이 부족하면, 
	   sendto() 함수 호출시 블록된다. 

*/




//---------------------------------------------------------------- 
//	4) example(송신)
//---------------------------------------------------------------- 

/*
#include <winsock2.h>

#define PORT	5000
void main()
{
	WSADATA			wsaData;
	SOCKET			SendSocket;
	SOCKADDR_IN		RecvAddr;

	char			Sendbuff[1024];
	int				nBytes		= 1024;



	// 1. 윈속 라이브러리 2.2 초기화
	WSAStartup(MAKEWORD(2,2), &wsaData);


	// 2. 연결을 기다리기 위한 소켓 생성
	SendSocket	= socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);


	// 3. 데이터를 전송할 주소 지정
    RecvAddr.sin_family		= AF_INET;
	RecvAddr.sin_port			= htons(PORT);
	RecvAddr.sin_addr.s_addr	= inet_addr("127.0.0.1");


	// 4. 데이터 전송
	sendto(SendSocket, Sendbuff, nBytes, 0, 
			(SOCKADDR*)&RecvAddr, sizeof(RecvAddr) );

	
	// 5. 소켓 해제
	closesocket( SendSocket);

	// 6. 윈속 사용 종료 
	WSACleanup();
}
*/




/*
	UDP	서버					UDP 클라이언트
		
		socket()					socket()

		bind()						

		recvfrom()					sendto()

		sendto()					recvfrom()

		closesocket()				closesocket()


   * 고려 사항
      블로킹 소켓의 경우 sendto(), recvfrom() 함수 호출 순서가 맞지 
	  않으면 교착 상태가 발생할 수 있다.

      클라이언트는 데이터를 받은 후 송신자의 주소를 확인해야 한다.
	  recvfrom 함수는 UDP 서버가 보낸 데이터는 물론, 
	  다른 UDP 애플리케이션이 보낸 데이터도 모두 수신하기 때문이다. 



   * 아래와 같이 내부적으로 통신할 상대의 주소 정보를 기억해두는 것도 
     가능하다(특정 서버와의 통신)

  		UDP	서버					UDP 클라이언트
		
		socket()					socket()

		bind()						connect(): 하나의 고정된 ip 
												주소/포트의 의미

		recvfrom()					send()

		sendto()					recv()

		closesocket()				closesocket()


     => 위의 모델의 장점
	    - sendto() 함수를 사용한 경우보다 속도가 빠르다.
		  connect() 함수로 서버 주소를 한 번만 설정해두면
		  send() 함수가 이 정보를 계속 사용할 수 있기 때문이다.

        - 데이터를 받은 후 송신자의 주소(IP, PORT)를 확인하지 않아도
		  됨
		  recvfrom() 함수와 달리 recv() 함수는 connect() 함수로 설정한
		  서버를 제외한 다른 UDP 애플리케이션이 보낸 데이터는 
		  수신하지 않기 때문이다. 

        * 주의사항
		  블로킹 소켓의 경우, 교착상태가 발생할 수 있다. 
*/



//---------------------------------------------------------------- 
//	5) example
//---------------------------------------------------------------- 
/*
  [ 실습 ] UDP 서버/ 클라이언트 

  - 서 버  : 클라이언트가 보낸 데이터를 받아(recvfrom), 
             이를 문자열로 간주하여 무조건 화면에 출력(printf)
			 받은 데이터를 변경없이 다시 클라이언트에게 전송(sendto)

  - 클라이언트: 사용자가 키보드로 입력한 문자열을(fgets) 서버에 
                전송(sendto)
                서버가 받은 데이터를 그대로 돌려보내면,
				클라이언트는 이를 받아(recvfrom) 화면에 출력(printf)
*/
