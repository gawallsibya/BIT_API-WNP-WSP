//------------------------------------------------------------------------------------
//  비동기 I/O 처리를 이용한 파일 접근
//   - CPU와 메모리의 속도가 빨라지고 있음에도 불구하고 애플리케이션
//     을 실행할 때 병목현상이 발생하는 원인은 주변기기와의 
//     입출력 때문임

//   - 디스크에 저장하는 IO의 경우 
//	   특히 디스크 드라이브에는 디스크를 회전시키는 모터와 데이터를 읽는 
//     헤드가 있기 때문에
//     메모리에 비해 데이터를 읽고 쓰는 데 걸리는 시간이 메우 길다.
//     그러나 CPU는 단순히 디스크 드라이브에 명령을 보낼 뿐이다.

//      대부분 처리시간은 디스크 드라이브에 쓰이며
//      CPU는 처리가 종료되기를 기다린다.

//      이때 CPU는 다른 스레드로 전환되므로 시스템 전체적으로 봤을때는
//      CPU가 쓸데없이 빈둥거리는 일은 없다.

//      이처럼 CPU가 놀고 있는 시간을 유효하게 사용하자는 것이 비동기 
//      IO(Asynchronous Input/Output)의 개념이다.

//       일반 I/O의 경우 파일을 읽고쓰는 ReadFile/WriteFile API는 읽기 /쓰기가 완료될때까지 
//       호출에서 복귀하지 않는다.

//       이에 반해 비동기 I/O는 처리를 받은 즉시 제어를 돌려준다.

//       그 후 실제로 읽기/쓰기가 완료되는 시점에서 통지해 주므로 그 동안 애플리케이션에서는 
//       다른 처리를 할 수 있다.


//       동기화 I/O)

//       ReadFile호출								     호출에서 복귀 

//                   하드디스크에 읽기 명령 ==> 처리 완료 


//       비동기 I/O

//		 ReadFile호출   호출에서 바로 복귀 => 다른 처리 실행 => 대기 API호출    호출에서 복귀 

//					하드디스크에 읽기명령	============================> 처리 완료 	
//---------------------------------------------------------------------------------------

/*

동기화 I/O 처리 
  디스크에 대한 읽기 쓰기가 완료될 때까지 API호출에서 
  복귀하지 않기 때문에 그 사이에 아무 것도 할 수 없다.

비동기 I/O 처리
  API를 호출하면 즉시 복귀하기 때문에 읽기 쓰기가 완료
  될 떄까지 다른 처리를 할 수 있다. 

  1) 디스크 접근 대기 시간을 유효하게 사용한다.
     API 함수를 비동기 적으로 처리 

  2) 이벤트 객체를 사용해서 처리 완료를 통지한다. 
     OVERLAPPED 구조체를 사용하여 처리 
  
  3) 처리 결과를 얻어온다.
     GetOverlappedResult API 

  4) 동기 I/O와 비동기 I/O는 섞어서 사용할 수 없다.

*/


