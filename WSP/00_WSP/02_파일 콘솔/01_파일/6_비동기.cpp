/****************************************************************************

  1) 디스크 접근 대기 시간을 유효하게 사용한다.

     최근에는 하드디스크도 상당히 빨라졌기 때문에 느리다는 느낌
	 이 들지 않을지 모른다.

     하지만 읽고 쓰는 데이터가 커지면 지연 속도를 체감할 수 있고,
	 네트워크를 경유하는 파일 접근의 경우에는 몇십초씩 걸리는 경우가
	 종종 있다.

     이는 Windows 같은 GUI application에서는 별로 바람직하지 않은
	 행동이다. 그 사이에 사용자가 전혀 조작하지 못하기 때문이다.

     이처럼 시간이 많이 필요한 처리에 멀티스레드가 효율적이라는 사실은
	 그대로지만, 배타적 제어나 동기화 처리 등을 적절히 하지 않으면
	 Application이 정상적으로 동작하지 않을 가능성이 있다.

	 파일 입출력과 같은 매우 기본적인 처리를 위해 멀티스레드를 사용해야
	 한다면 왠지 불편하다는 생각이 들고, 멀티스레드를 지원하지 못하는
	 상용 라이브러리를 사용해야 하는 경우도 있을 수 있다.

	 이런 문제는 비동기 I/O를 사용해 해결할 수 있다.


     BOOL ReadFile(			// 반환값 : 성공이면 true
		HANDLE hFile,		// 읽을 파일 핸들
		LPVOID lpBuffer,	// 읽어올 버퍼의 주소
		DWORD  nNumberof..  // 읽을 바이트 수
		LPDWORD lpNum...	// 실제 읽은 바이트 수
		LPOVERLAPPED lpO..	// OVERLAPPED 구조체의 주소 
		);

     ==> 제일 마지막 인자 NULL : 동기 I/O 처리
	     적절하게 초기화된 OVERLAPPED 구조체 포인터 지정 : 비동기 I/O

     비동기 I/O에서는 ReadFile/WriteFile API로 시간이 필요한 읽기 쓰기를
	 하면 처리가 완료되기 전에 복귀힌다.
	 그러나 Windows의 내부 처리가 크게 다른 것은 아니다.
	 동기 I/O에서도 비동기 I/O에서도 API요청을 받아 Windows에서 파일의
	 읽기 쓰기를 수행한다는 사실에는 변화가 없다.
	 동기 I/O일 경우에는 항상 처리가 종료될 때까지 API 내부에서 대기하도록
	 되어 있을 뿐이다. 비동기 I/O를 지정하더라도 짧은 시간에 처리가 끝나는
	 경우에는 처리 완료 후에 복귀하는 일도 있다.

	 호출에서 복귀한 시점부터 처리가 완료되었는지를 확인하려면 API반환값을
	 보면 된다. true가 반환되면 이미 처리가 정상적으로 완료된 것이다.
	 처리가 완료되지 않았을 경우에는 false 가 반환된다.

	 그러나 이것만으로는 에러가 발생한 경우와 구별되지 않기 때문에
	 GetLastError API를 호출해서 확장 에러 코드를 조사할 필요가 있다.
	 만약 에러 코드가 ERROR_IO_PENDING 이라면 처리가 정상적으로 시작되었
	 으나 아직 완료되지 않은 상태라는 의미이다.

****************************************************************************/










